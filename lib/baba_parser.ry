class BabaParser
  token LEFT_PAREN RIGHT_PAREN COMMA MINUS PLUS SLASH STAR SEMICOLON LEFT_BRACE DOT MODULO
  token NOT NOT_EQUAL EQUAL EQUAL_EQUAL GREATER LESS GREATER_EQUAL LESS_EQUAL
  token IDENTIFIER STRING NUMBER CONSTANT
  token THING IF ELSE DOES FOR BLANK OR AND RETURN SUPER SELF VAR WHILE FALSE TRUE RIGHT_BRACE BREAK SWITCH WHEN NEXT
  token AWAIT YIELD ELSIF

  rule
    program: declarations

    declaration: thing_declaration
    | does_declaration
    | var_declaration
    | statement

    declarations: { return [] }
    | declaration { return val }
    | declarations declaration { return val[0] << val[1] }

    thing_declaration: THING CONSTANT LEFT_BRACE does_declarations RIGHT_BRACE { return Baba::Stmt::Class.new(val[1], nil, val[3]) }
    | THING CONSTANT LESS CONSTANT LEFT_BRACE does_declarations RIGHT_BRACE { return Baba::Stmt::Class.new(val[1], val[3], val[5]) }

    does_declaration: DOES function { return val[1] }

    does_declarations: { return [] }
    | does_declaration { return val }
    | does_declarations does_declaration { return val[0] << val[1] }

    var_declaration: VAR IDENTIFIER { return Baba::Stmt::Var.new(val[1], nil)  }
    | VAR IDENTIFIER EQUAL expression { return Baba::Stmt::Var.new(val[1], val[3]) }

    function: IDENTIFIER LEFT_PAREN opt_parameters RIGHT_PAREN block { return Baba::Stmt::Function.new(val[0], val[2], val[4]) }

    opt_parameters: { return [] }
    | IDENTIFIER { return val }
    | IDENTIFIER COMMA opt_parameters { return [val[0], val[2]].flatten }

    statement: expression
    | for_stmt
    | if_statement
    | return_statement
    | switch_statement
    | while_statement
    | yield_statement
    | block

    for_stmt: FOR for_initializer COMMA opt_expression COMMA opt_expression statement { return Baba::Stmt::For.new(val[1], val[3], val[5], val[6]) }

    for_initializer: # empty
    | var_declaration
    | expression

    if_statement: IF expression statement { return Baba::Stmt::If.new(val[1], val[2], nil) }
    | IF expression statement ELSE statement { return Baba::Stmt::If.new(val[1], val[2], val[4]) }
    | IF expression statement elsif_statement { return Baba::Stmt::If.new(val[1], val[2], val[3]) }

    elsif_statement: ELSIF expression statement elsif_statement { return Baba::Stmt::If.new(val[1], val[2], val[3]) }
    | ELSIF expression statement { return Baba::Stmt::If.new(val[1], val[2], nil) }
    | ELSIF expression statement ELSE statement { return Baba::Stmt::If.new(val[1], val[2], val[4]) }

    return_statement: RETURN expression { return Baba::Stmt::Return.new(val[1]) }
    | RETURN { return Baba::Stmt::Return.new(nil) }

    switch_statement: SWITCH expression LEFT_BRACE cases RIGHT_BRACE { return Baba::Stmt::Switch.new(val[1], val[3], nil) }
    | SWITCH expression LEFT_BRACE cases ELSE statement RIGHT_BRACE { return Baba::Stmt::Switch.new(val[1], val[3], val[5]) }

    cases: WHEN expression statement { return Baba::Stmt::When.new(val[1], val[2]) }
    | WHEN expression statement cases { return [Baba::Stmt::When.new(val[1], val[2]), val[3]].flatten }

    while_statement: WHILE expression statement { return Baba::Stmt::While.new(val[1], val[2]) }

    yield_statement: YIELD { return Baba::Stmt::Yield.new(nil) }
                   | YIELD expression { return Baba::Stmt::Yield.new(val[1]) }

    block: LEFT_BRACE declarations RIGHT_BRACE { return Baba::Stmt::Block.new(val[1]) }

    expression: assignment

    opt_expression: # empty
    | expression

    assignment: IDENTIFIER EQUAL assignment { return Baba::Expr::Assign.new(val[0], val[2]) }
    | call DOT IDENTIFIER EQUAL assignment { return Baba::Expr::Set.new(val[0], val[2], val[4]) }
    | logic_or

    logic_or: logic_and
    | logic_and OR logic_or { return Baba::Expr::Logical.new(val[0], val[1], val[2]) }

    logic_and: equality
    | equality AND logic_and { return Baba::Expr::Logical.new(val[0], val[1], val[2]) }

    equality: comparison
    | comparison opt_equality equality { return Baba::Expr::Binary.new(val[0], val[1], val[2]) }

    opt_equality: EQUAL_EQUAL
    | NOT_EQUAL

    comparison: term
    | term opt_comparison comparison { return Baba::Expr::Binary.new(val[0], val[1], val[2]) }

    opt_comparison: GREATER_EQUAL
    | LESS_EQUAL
    | GREATER
    | LESS

    term: factor
    | factor opt_term term { return Baba::Expr::Binary.new(val[0], val[1], val[2]) }

    opt_term: MINUS
    | PLUS

    factor: unary
    | unary opt_factor factor { return Baba::Expr::Binary.new(val[0], val[1], val[2]) }

    opt_factor: SLASH
    | STAR
    | MODULO

    unary: opt_unary unary { return Baba::Expr::Unary.new(val[0], val[1]) }
    | call

    opt_unary: MINUS
    | NOT

    call: primary
    | call LEFT_PAREN opt_arguments RIGHT_PAREN { return Baba::Expr::Call.new(val[0], val[2]) }
    | call DOT IDENTIFIER { return Baba::Expr::Get.new(val[0], val[2]) }

    opt_arguments: { return [] }
    | expression { return val }
    | expression COMMA opt_arguments { return [val[0], val[2]].flatten }

    primary: IDENTIFIER { return Baba::Expr::Variable.new(val[0]) }
    | NUMBER { return Baba::Expr::Literal.new(val[0]) }
    | STRING { return Baba::Expr::Literal.new(val[0]) }
    | TRUE { return Baba::Expr::Literal.new(true) }
    | FALSE { return Baba::Expr::Literal.new(false) }
    | BLANK { return Baba::Expr::Literal.new(nil) }
    | BREAK { return Baba::Expr::Break.new }
    | NEXT { return Baba::Expr::Next.new }
    | SUPER DOT IDENTIFIER { return Baba::Expr::Super.new(val[2]) }
    | LEFT_PAREN expression RIGHT_PAREN { return Baba::Expr::Grouping.new(val[1]) }

end

----header
require_relative 'stmt'
require_relative 'expr'
require_relative 'lexer'
